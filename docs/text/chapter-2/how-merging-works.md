# マージのしくみ

前章で示したコンフリクトの解決方法についていくつかの疑問を抱いた人がいるかも知れません。

- なぜ 2 つのコンフリクトが同様の方法で解決できるのか？
- 毎回の同期のプルの中でマージをしているなら、なぜコミットグラフが輪っかだらけにならないのか？

これは Git におけるマージという動作の仕組みに関わる疑問です。少し発展的な内容になりますが、興味を持った方のために説明しようと思います。

## 3-way merge

main ブランチの状態 O から sub ブランチを生やし、main ブランチと sub ブランチのそれぞれにコミットをしていったとします。その後、状態 Y まで進んだ sub ブランチを状態 X まで進んだ main ブランチにマージすることになりました。

![](https://md.trap.jp/uploads/upload_b68dd1f1c5a09a34ce8c46c1e7f418c8.png)

Git はマージの実装に **3-way merge** と呼ばれる方式を採用しています。簡単に説明すると、**状態 O, X, Y の 3 つだけを用いてマージ後の状態 Z を生成する**という方式です。

具体的なマージの手順を以下に示します。

1. 状態 O と 状態 X から差分 A' を導く。同様に、状態 O と 状態 Y から差分 B' を導く
2. 差分 A' と 差分 B' を合成して合成差分を得る（コンフリクトの発生源）
3. 状態 O に合成差分の変更を施した結果の状態 Z を得る
4. sub → main 方向のマージなので、main の先端に Z をつけてマージコミットを作成する
5. マージコミットの「変更内容」は X と Z の差分から後付けで導く

:::tip コミットグラフを構成する要素
コミットグラフにおいて、点（ノード）は**リポジトリのある状態**を表し、矢印（エッジ）は**状態同士の親子関係**を表します。単一ブランチ内でのコミットをはじめとして、ほとんどの場合で矢印は「（根本の状態から先端の状態への）変更」と同義です。しかし、ブランチ同士が合流するマージコミットのように、矢印が単に「変更」を意味するとは言えない場合もあります。

先ほどの図で Y → Z 方向の矢印を実線ではなく点線で示したのは、この矢印が「変更」を意味しないからです。Z は確かに状態 X と Y 両方の子の状態ですが、マージコミットにおける sub の寄与としては「main の新しいコミットに sub の情報が用いられた」に過ぎず、sub → main のマージの後も依然として sub の先端は Y のままになっています。
:::

3-way merge における重要な点をいくつか挙げます。

- O から X, Y に至るまでのコミット群 A, B の途中経過は**マージの結果に影響しません**。Z を決めるのは専ら O, X, Y の 3 つのノードであり、それ以外は参照されません。
- 合成差分を得るとき、差分 A' と B' は同列に扱われます。すなわち、main → sub のマージと sub → main のマージでは**全く同じ状態 Z が得られる**ことになります。ただし、Z がつく部分が main の先端になるか、sub の先端になるかはマージの方向によって異なります。

:::tip マージ競合の解決
前章で紹介したマージ競合の解決方法は大まかに以下の流れを辿りました。

1. **main → sub のマージ**（コンフリクトの解決を伴う）
2. **sub → main のマージ**（PR を立てる）

この説明を聞いて「**main → sub 方向のマージのコンフリクトを解決することで、なぜ直ちに sub → main 方向のマージのコンフリクトも解決できるのか？**」と疑問に思った方はとても鋭いです。その理由はここで説明した 3-way merge の仕組みに基づいて述べることができます。

3-way merge においてマージ後の状態の生成に用いられるのは「それぞれのブランチの最新の状態」そして「**それらの最も近い共通の祖先**」です。main → sub 方向のマージによって、main の最新状態は X、sub の最新状態は Z になります。これらの最も近い共通の祖先は X 自身であり、Z はその子にあたる状態です。従って、続けて sub → main のマージをする際には X → Z の差分をそのまま合成差分として用いることができます。差分の合成においてコンフリクトが生じることはありません。

![](https://md.trap.jp/uploads/upload_6cca7b85d6c6811a7010e38ff59b6eea.png)
:::

## Fast-Forward merge

前編 [Git の操作の実体](/text/chapter-1/git-commands.html) の章で触れた通り、pull とは fetch + merge です。VSCode 上で「変更の同期」ボタンを押すたびに 3-way merge の処理が走るということになります。

しかし、それにしてはコミットグラフにマージの形跡が見当たりません。これは、最後の同期以後ローカルにコミットが一つもない場合 pull のマージでは **Fast-Forward merge** と呼ばれる特殊なマージ処理がはたらく条件が整っているからです。

![](https://md.trap.jp/uploads/upload_69385f8e803b6a200ae80e2acb986ad3.png)

Fast-Forward merge は、マージ先のブランチが共通の根から一度もコミットされていない場合に限り、マージ元のブランチにおける全ての変更をマージ先のブランチで行っていたことにできるマージ処理です。上の図では origin/main（マージ元のリモートブランチ）におけるすべての変更が main（マージ先のローカルブランチ）でも行っていたことにされています。

ただし、この Fast-Forward merge を条件によって発動させない設定にすることもできます。たとえば、プルリクエストを立てて行った main へのマージでは、たとえ main からブランチを生やしてから一度も main に動きがなかったとしても「ブランチを生やしてコミットしてからマージした」という履歴を残したい場合があります。このようなニーズに対応し、Gitea などホスティングサービスの側で「プルリクエストを立てた場合に Fast-Forward merge を無効にする」設定がリポジトリ単位で可能になっていることが多いです。

:::tip ローカルにもコミットが存在した場合の pull
リモートとの最後の同期以後、リモートブランチとローカルブランチの双方にコミットが存在した場合、Fast-Forward merge は発動せず、pull によってマージコミットが作成されることになります。

main どっち問題
:::

## 

rebase cherry-pick 関連はこのページに項をとって軽く説明するかtipにまとめておけばいいでしょ

##