import{_ as r,c as a,o as e,ag as o}from"./chunks/framework.DPDPlp3K.js";const b=JSON.parse('{"title":"リポジトリ","description":"","frontmatter":{},"headers":[],"relativePath":"text/chapter-2/repository.md","filePath":"text/chapter-2/repository.md"}'),s={name:"text/chapter-2/repository.md"};function i(p,t,n,l,c,h){return e(),a("div",null,t[0]||(t[0]=[o('<h1 id="リポジトリ" tabindex="-1">リポジトリ <a class="header-anchor" href="#リポジトリ" aria-label="Permalink to &quot;リポジトリ&quot;">​</a></h1><p>前編で説明したブランチの仕組みだけでも個人開発や小規模な共同開発では十分かも知れませんが、中規模以上の共同開発に供するには心許ない節があります。なぜなら、この仕組みは今のところ「変更の履歴が残るクラウドストレージ」以上の何物でもないからです。</p><h2 id="共同開発とブランチ" tabindex="-1">共同開発とブランチ <a class="header-anchor" href="#共同開発とブランチ" aria-label="Permalink to &quot;共同開発とブランチ&quot;">​</a></h2><p>共同開発ではプロダクトの複数の部分のそれぞれで同時に開発が進むことが一般的です。1 本のブランチの中に各部分の変更のコミットが入り乱れると当然コミットグラフは見にくくなりますが、問題はそれだけではありません。</p><div class="tip custom-block"><p class="custom-block-title">Web 開発と 1 本のブランチ</p><p>操作可能な Web ページとして提供されるサービスを一般に Web アプリと呼びます。Web アプリの本体は大きく <strong>フロントエンド</strong> と <strong>バックエンド</strong> に分かれた構造をしています。</p><ul><li><strong>フロントエンド</strong>：ユーザーが Web アプリにアクセスした瞬間にユーザーのデバイスに送信され、そこで動いて Web ページの表示を担う HTML + CSS + JavaScript のシステム</li><li><strong>バックエンド</strong>：サーバーで待機している倉庫番。フロントエンドから送られたデータを受け取ってデータベースに保存したり、フロントエンドの注文に応じて取り出して送信したりする</li></ul><p>フロントエンドを開発するためにはバックエンドが正しく動かせる状態にある必要があります。フロントエンドは Web ページにデータをどう表示するかの部分を担いますが、肝心のデータ（画像やテキスト）がバックエンドから送られてこなければ Web ページの表示は崩れてしまいます。</p><p>ここで、バックエンドのシステムに大きな変更が必要になったとしましょう。変更の途中では当然バックエンドは不完全であり、全く動かない可能性もあります。この場合、バックエンドの担当が優しければフロントエンドの開発を妨げないためにブランチの外側で（Git に頼らず）開発をすることになりそうです。しかしもしバックエンドが譲らない場合、フロントエンドの担当は正しく動く過去のバックエンドのシステムを手元で動かしながらブランチの外側で開発することになります。いずれにせよ、1 本のブランチの上に複数の部分の開発を共存させることは多大な困難を伴います。</p></div><p>ごく簡単にいうと「<strong>重要な部分の開発中は他の部分の開発がストップする</strong>」ことが一番の問題です。この問題を解決するために、Git では枝という名の通りブランチから別のブランチを「<strong>生やす</strong>」ことができます。この機能が Git を便利なツールたらしめる最重要要素です。</p><p>あるコミットを起点としたブランチを「生やす」という操作は、そのコミットを「分岐点」としてそこから別の開発を始めることを意味します。</p><h2 id="リポジトリ-1" tabindex="-1">リポジトリ <a class="header-anchor" href="#リポジトリ-1" aria-label="Permalink to &quot;リポジトリ&quot;">​</a></h2><p>長らく「リポジトリ」という言葉を説明なしに用いてきました。リポジトリとは <strong>ある共通の根を持つブランチの集合</strong> を表します。ブランチ一つ一つは「根っこの状態」と「その後の一連のコミット」の情報を持っているので、リポジトリは（特殊な操作をしない限り）過去あらゆる状態の履歴を持っていることになります。</p><p>traP における大抵の開発では、リポジトリは以下のように運用されています。</p><ul><li>main ブランチを常にシステムとして健全に動くようにしておく</li><li>main ブランチから「変更のブランチ」を生やし、その中で変更を済ませてから main に反映</li></ul><p>この流れは <a href="https://docs.github.com/ja/get-started/using-github/github-flow" target="_blank" rel="noreferrer">GitHub Flow</a> と呼ばれています。これによって、他の部分が健全に動くことを想定して各部分の開発に取り組むことができるようになります。中規模以上のプロジェクトでも、このリポジトリ・ブランチの仕組みがあれば十分に回るというわけです。</p><div class="tip custom-block"><p class="custom-block-title">モノリポとポリリポ</p><p>ところが、共同開発を強力に支えるこのリポジトリの仕組みを以てしても管理が追いつかなくなるような大規模なプロジェクトは世の中に少なからず存在します。一つのプロジェクトを一つのリポジトリにおさめて管理することを「<strong>モノリポ</strong>」と呼び、それ自体が「<strong>ポリリポ</strong>」と呼ばれる対照的な管理形態の存在を暗示しています。</p><p>一つのプロジェクトを複数のリポジトリで分割して管理することにはいくつかメリットがあります。たとえば、開発者の Git 操作の権限はリポジトリごとに与えられるので、開発者が変更可能な領域を明確にできるという意味ではポリリポは良い選択です。</p><p>traP のプロジェクトとしては例えば traQ がポリリポを採用していて、フロントエンド（<a href="https://github.com/traPtitech/traQ_S-UI" target="_blank" rel="noreferrer">traQ_S-UI</a>）とバックエンド（<a href="https://github.com/traPtitech/traQ" target="_blank" rel="noreferrer">traQ</a>）の 2 つのリポジトリに分かれています。一方、プロジェクトの初期段階ではチーム全体で設計の擦り合わせをしながら開発を進めていくためにモノリポの方が都合がよいことも多いです。モノリポとポリリポのどちらにも他方より良い点があり、どちらがより適しているかはプロジェクトの規模や内容によりけりです。</p></div>',13)]))}const d=r(s,[["render",i]]);export{b as __pageData,d as default};
