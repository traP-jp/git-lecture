import{_ as e,c as a,o,ag as i}from"./chunks/framework.DPDPlp3K.js";const h=JSON.parse('{"title":".gitignore","description":"","frontmatter":{},"headers":[],"relativePath":"text/chapter-3/gitignore.md","filePath":"text/chapter-3/gitignore.md"}'),s={name:"text/chapter-3/gitignore.md"};function r(n,t,p,g,l,d){return o(),a("div",null,t[0]||(t[0]=[i(`<h1 id="gitignore" tabindex="-1">.gitignore <a class="header-anchor" href="#gitignore" aria-label="Permalink to &quot;.gitignore&quot;">​</a></h1><p>既存のリポジトリをいくつか見て回っていると、よく <code>.gitignore</code> という名前のテキストファイルを目にします。簡単にいうと、これはリポジトリに載せないファイルの名簿です。</p><h2 id="gitignore-のはたらき" tabindex="-1">.gitignore のはたらき <a class="header-anchor" href="#gitignore-のはたらき" aria-label="Permalink to &quot;.gitignore のはたらき&quot;">​</a></h2><p>.gitignore が持つ効果については実例を見た方が分かりやすいかも知れません。まず、リポジトリに <code>.gitignore</code> という名前（最初にピリオドをつける）の空のテキストファイルを作成し、そこに <code>secret.md</code> とだけ書いて変更をコミットしてしまいましょう。</p><p><img src="https://md.trap.jp/uploads/upload_afb00e41b7c969a1b867d51803f6f36d.png" alt=""></p><p>さらに <code>secret.md</code> という名前の空のテキストファイルを作成して編集します。</p><p><img src="https://md.trap.jp/uploads/upload_c42709799b91b87e60ae444c6c013b8a.png" alt=""></p><p>すると、変更を保存していつまで待っても『ステージされている変更』に secret.md の表示が出ず、コミットができなくなりました。エクスプローラータブでファイルの一覧を見直してみると、どうも secret.md だけファイル名の表示が暗くなっています。</p><p><img src="https://md.trap.jp/uploads/upload_2c8d8f54e90d1c77f9668bdfdc7a0855.png" alt=""></p><p>これは先ほど作った .gitignore の効力です。リポジトリに .gitignore というファイルが含まれていると、Git は<strong>そこに名前が書かれたファイルをすべてコミットから除外</strong>します。<code>secret.md</code> と書かれたファイル .gitignore をリポジトリに追加したことで、secret.md は<strong>作業ディレクトリの中に存在するにも拘らずリポジトリには含まれなくなった</strong>のです。</p><p>ちなみに、.gitignore はただファイル名を列挙するだけでなく、ディレクトリ名を書いてそこに含まれるファイルを丸ごと除外したり、同じ種類の（たとえば共通の拡張子を持つ）ファイルをいっぺんに除外したりすることもできます。</p><h2 id="gitignore-の使い道" tabindex="-1">.gitignore の使い道 <a class="header-anchor" href="#gitignore-の使い道" aria-label="Permalink to &quot;.gitignore の使い道&quot;">​</a></h2><p>一般に、<strong>リポジトリには必要最小限のファイルを載せるべき</strong>とされています。リポジトリそのものにキツい容量制限があるわけではないですが、明らかに必要なファイルだけが入ったリポジトリの方が整然としていて見通しがよくて開発がスムーズに進む、といえばなんとなく納得できるかと思います。.gitignore は「<strong>作業ディレクトリに存在するがリポジトリには載せたくないファイル</strong>」を除去するために重宝されています。</p><p>共同開発で .gitignore がどう活用されているかについては実例を見た方が早いかも知れません。GitHub 上の traQ フロントエンドリポジトリのルートに置かれている <a href="https://github.com/traPtitech/traQ_S-UI/blob/master/.gitignore" target="_blank" rel="noreferrer">.gitignore</a> を見てみましょう。以下はその最初の数行です。</p><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.DS_Store</span></span>
<span class="line"><span>node_modules</span></span>
<span class="line"><span>/dist</span></span>
<span class="line"><span></span></span>
<span class="line"><span># local env files</span></span>
<span class="line"><span>.env.local</span></span></code></pre></div><p><code>#</code> から始まる行はコメントなので無視してください。そのほかの 4 行は .gitignore をそれぞれ異なる方法で用いています。実は、.gitignore の代表的な使い方はここにあるもので凡そ網羅されています。それぞれ見ていきましょう。</p><h3 id="ds-store-の除外" tabindex="-1">.DS_Store の除外 <a class="header-anchor" href="#ds-store-の除外" aria-label="Permalink to &quot;.DS_Store の除外&quot;">​</a></h3><p>.DS_Store とは、Mac 内の任意の場所に新規作成したディレクトリ内での操作に関する情報を保存するためにその中に自動で生成されるファイルです。Finder 上では完全に隠蔽されていて、<code>Shift</code> + <code>Command</code> + <code>.</code> によって隠しファイル表示モードにしても表示されません。</p><p>ところが .DS_Store が隠蔽されるのは Mac の Finder だけです。リポジトリに含まれれば Gitea や GitHub 上でも普通に表示されるし、Windows にクローンしても顕についてきます。開発に必要なファイルではないのでリポジトリからは除外しておきたいところです。</p><p>というわけで .gitignore に .DS_Store と書かれています。第 1 行がこのファイルであることからも、.DS_Store がよく .gitignore に書かれるお邪魔ファイルの筆頭であることが伺えます。</p><h3 id="モジュールの除外" tabindex="-1">モジュールの除外 <a class="header-anchor" href="#モジュールの除外" aria-label="Permalink to &quot;モジュールの除外&quot;">​</a></h3><p>ここからは Web 開発の多少込み入った話になります。2 行目の node_modules は Node.js を用いた開発において <strong>パッケージがダウンロードされるディレクトリ</strong> です。</p><p>Web 分野に限らず、開発とは必ずしも全てを独力でなんとかするのではなく、先人が作ったプログラムのまとまり「<strong>パッケージ</strong>」をお借りしてシステムに組み込みながら進めていくことが一般的です。そのために Web に公開されているパッケージをダウンロードして管理する「<strong>パッケージマネージャ</strong>」と呼ばれるソフトウェアがプログラミング言語ごとに存在します。ちなみに、パッケージマネージャは Git 同様に代表的な CLI ソフトウェアの一種です。</p><p>パッケージマネージャの基本的な役割は「<strong>パッケージリストファイルに記されたパッケージを指定の場所にダウンロードする</strong>」ことです。パッケージリストファイルとは、必要なパッケージの名前や ID が決まった形式で列記されたテキストファイルのことです。</p><p>Node.js を用いた開発では npm（Node Package Manager）というパッケージマネージャが存在して、package.json というパッケージリストファイルを参照しながらパッケージを管理します。以下のようにコマンドを打てば「package.json に記されたパッケージをダウンロードして node_modules ディレクトリに追加」してくれます。</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # Node パッケージのインストール</span></span></code></pre></div><p>つまり、npm とリポジトリの中の package.json さえあれば各環境で必要なパッケージをダウンロードして揃えることができます。とすれば、その保存先である node_modules ディレクトリは必ずしもリポジトリに含める必要はないということになります。</p><div class="tip custom-block"><p class="custom-block-title">外部モジュールのとても雑な例え話</p><p>リュック 1 つと青春 18 きっぷで東海道線沿線を旅したくなったとします。貴重品など代えが利かないものは持参する必要がありますが、当然リュックは軽い方が嬉しいので、歯ブラシやシャンプー、タオル、食べ物など現地調達可能なものはなるべく現地調達することにして、必要なものと一緒に調達したいもののメモだけをリュックに入れておくことにします。</p><ul><li>リュック -&gt; <strong>リポジトリ</strong></li><li>貴重品 -&gt; <strong>オリジナルのソースコード</strong></li><li>現地調達可能なもの -&gt; <strong>外部パッケージ</strong></li><li>現地 -&gt; <strong>システムが動く環境</strong></li><li>現地調達するもののメモ -&gt; <strong>パッケージリストファイル</strong></li></ul><p>対応させるならこんな感じでしょうか。外部パッケージは <strong>システムが動く環境で / パッケージマネージャが / パッケージリストファイルをもとに調達してくれる</strong> ものなので <strong>リポジトリに含める必要がない</strong> という要点をおさえるために旅にたとえてみました。また行きたい。</p></div><p>というわけで .gitignore に node_modules と書かれています。node_modules はディレクトリ名なので、ここに含まれるパッケージを一薙ぎに除外してしまおうという寸法です。</p><h3 id="生成物の除外" tabindex="-1">生成物の除外 <a class="header-anchor" href="#生成物の除外" aria-label="Permalink to &quot;生成物の除外&quot;">​</a></h3><p>3 行目の dist とは <strong>ビルド成果物を保存するディレクトリ</strong> です。<a href="/text/chapter-2/repository.html#共同開発とブランチ">リポジトリ</a> の章で「Web フロントエンドは HTML + CSS + JavaScript で出来ている」ことに軽く触れましたが、ビルドされた HTML + CSS + JavaScript のシステムが収められる場所がこの dist です。ビルドという作業については <a href="https://traptitech.github.io/naro-text/" target="_blank" rel="noreferrer">Web エンジニアになろう講習会</a> で実践できるでしょう。</p><p>同一のリポジトリを異なる場所にクローンしても、それぞれでビルドすれば同じものが出来上がります。各環境でビルドすればよいので、ビルドの結果はリポジトリに含めておく必要がありません。このほかにも、リポジトリから復元可能なデータや一時的にしか使わないデータの形式や保存場所は .gitignore に追加してリポジトリに含めないことが一般的です。</p><h3 id="環境変数設定ファイルの除外" tabindex="-1">環境変数設定ファイルの除外 <a class="header-anchor" href="#環境変数設定ファイルの除外" aria-label="Permalink to &quot;環境変数設定ファイルの除外&quot;">​</a></h3><p>6 行目の .env.local は <strong>環境変数を書いておくファイル</strong> です。</p><p>開発したシステムをずっと動かしておきたい場合、自分の PC で動かしておくわけにもいかないので、<a href="https://ns.trap.jp" target="_blank" rel="noreferrer">NeoShowcase</a> などの外部の環境に <strong>デプロイ</strong>（移設）することになります。システムに対し環境ごとに異なる値を与えたい場合、それらは <strong>環境変数</strong> として与えます。NeoShowcase にも登録したアプリケーションそれぞれに環境変数を設定できる UI が存在します。</p><p><img src="https://md.trap.jp/uploads/upload_37df31b5612b2a7c87af06a9658a780f.png" alt=""></p><p>開発中のシステムが参照する環境変数は作業ディレクトリの内部に .env のような分かりやすい名前がついたファイルを用意して書いておくと便利なことが多いです。その上で、本番環境に予め設定してある環境変数と競合を生じないよう、.gitignore に .env を加えてリポジトリからは除外しておく運用が一般的です。</p><p>ちなみに、紛らわしくも運用によっては .env が『環境に依存しない定数』を書く場所として用いられリポジトリに含まれることがあるので、本来の .env の役割である『環境依存』というニュアンスを強めて .env.local という名前が用いられることもよくあるみたいです。</p><div class="tip custom-block"><p class="custom-block-title">.gitignore のテンプレート</p><p>リポジトリの作成時に Gitea 側で .gitignore のテンプレートを含めるよう設定することもできます。作りたいシステムで使用する言語・フレームワークごとに豊富なテンプレートが用意されています。</p><p><img src="https://md.trap.jp/uploads/upload_66b56f43c0a0b3abfc352d07ece19a68.png" alt=""></p></div><h2 id="環境変数と機密情報の秘匿" tabindex="-1">環境変数と機密情報の秘匿 <a class="header-anchor" href="#環境変数と機密情報の秘匿" aria-label="Permalink to &quot;環境変数と機密情報の秘匿&quot;">​</a></h2><p>traP Gitea 上のリポジトリは部員に対してのみ公開されますが、GitHub などのホスティングサービスを使う場合は Web 上に公開された Git リポジトリで開発を進めていくことも珍しくありません。それどころか、GitHub の無料会員は 2018 年までプライベートリポジトリを作ることが出来ませんでした。</p><p>実行中のシステムが必要とする情報のうち、API トークン（パスワード）など外部に悪用されないように秘匿しておきたい文字列もよく環境変数として扱われます。実際に環境に依存するか否かはさておき、.gitignore の恩恵でリポジトリに含まれなくなった .env はこうした機密情報を置いておくにはうってつけの場所です。</p><p>ただし、<strong>一度コミットされたファイルをあとで .gitignore に追加してもリポジトリからは除外されない</strong> ことに注意が必要です。たとえば、</p><ol><li>空の secret.md を作業ディレクトリに追加してコミット</li><li>secret.md と書いた .gitignore を追加してコミット</li><li>secret.md に秘密にしたい情報を書き込む</li></ol><p>この場合、secret.md は手順 1 によってすでにリポジトリに含まれているので、3 で行った変更もコミット可能になっています。一旦「secret.md の削除」という変更をコミットして初めて .gitignore の記述が効力を発するようになります。</p><hr><p>リポジトリには基本的に全てのコミットの履歴が残ります。それ以前に、一度インターネットに流出した情報を完全に消すのは非常に難しいことです。.gitignore のはたらきをよく理解した上で、公開リポジトリへのコミットはぜひ慎重にお願いします。まずはプライベートリポジトリで色々な操作に慣れておくとよいでしょう。</p>`,47)]))}const m=e(s,[["render",r]]);export{h as __pageData,m as default};
